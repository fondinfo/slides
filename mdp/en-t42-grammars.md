![](http://fondinfo.github.io/images/comp/attack.svg)
# Grammars
## Introduction to Computer Science <br> Michele Tomaiuolo @ Ingegneria UniPR

---

![](http://fondinfo.github.io/images/hist/chomsky.png) Noam Chomsky in 2017
# üí°Ô∏è Chomsky Grammars

- Grammar `$G := <V_t, V_n, P, S>$`
    - `$V_t$`: finite alphabet of **terminal** symbols
    - `$V_n$`: ‚Ä¶ **non-terminal** symbols (variables, syntactic categories)
    - `$V := V_t \cup V_n$`
    - `$P$`: set of **productions**, <br> binary relation `$V^\star \cdot V_n \cdot V^\star \times V^\star$` <br> `$<\alpha, \beta> \in P$` is denoted by `$\alpha \to \beta$`
    - `$S \in V_n$`: **axiom**
- `$L(G)$`: set of terminal strings obtainable with finite rewrite operations
    - Application of production rules, in various ways

---

# üí°Ô∏è Language Generated by G

- *Direct derivation* `$\to$`: rewriting of a string by applying a production rule
- *Derivation* `$\to^\star$`: reflexive and transitive closure of direct derivation
- *Sentential form*: string `$x : x \in V^\star, S \to^\star x$`
- *Language generated* by `$G$`: sentential forms with only terminal symbols
    - `$L(G) := \{x : x \in V_t^\star, S \to^\star x\}$`
- *Equivalence* between `$G_1$` and `$G_2$`: `$L(G_1) = L(G_2)$`

---

![large](http://fondinfo.github.io/images/comp/grammar11.svg)
# ‚≠ê Parse Tree

- The root of the tree is the *axiom*
- Each node has as many children as there are applicable *productions*
- Each child is a *sentential form*
- The leaves are strings of the language, with only *terminal* symbols
- Productions with the same left part: grouped with ‚Äú`$|$`‚Äù
- `$G_{11} := <\{a,b\}, \{F\}, P_{11}, F>$`
- `$P_{11} := \{F \to ab, F \to aFb\} = \{F \to ab | aFb\}$`

---

![large](http://fondinfo.github.io/images/comp/grammar12.svg)
# ‚≠ê Equivalent Grammar


- `$G_{12} := <\{a,b\}, \{F,G\}, P_{12}, F>$`
- `$P_{12} := \\ \{F \to ab, F \to aG, G \to Fb\} = \\ \{F \to ab | aG, G \to Fb\}$`
- `$G_{11}$` and `$G_{12}$` are equivalent
    - They generate the same language

---

# üß™ Comparing Grammars

- Productions of `$G_{21}$`
    - `$S \to b | aA \\ A \to aS$`
- Productions of `$G_{22}$`
    - `$S \to Ab | b \\ A \to aAa | aa$`
- Productions of `$G_{23}$`
    - `$S \to Ab \\ A \to Aaa | \varepsilon$`
- Three grammars, all with alphabets `$\{a, b\}$`, `$\{S, A\}$` and axiom `$S$`
- ‚ùì Are `$G_{21}, G_{22}, G_{23}$` equivalent? Generate the 3 *parse trees*
    - They all generate the language `$\{a^{2n}b\}$`

---

# üß™ Generation Exercise

- Grammar for the language `$\{a^n b^n c^n : n\geq1\}$`
- `$G_0 := <\{a, b, c\}, \{S, B, C\}, \{P_1, P_2, P_3, P_4, P_5, P_6, P_7\}, S> \\
P_1 := S \to aSBC \\
P_2 := S \to aBC \\
P_3 := CB \to BC \\
P_4 := aB \to ab \\
P_5 := bB \to bb \\
P_6 := bC \to bc \\
P_7 := cC \to cc$`
- ‚ùì Find the productions that generate $aaabbbccc$
    - Solution: `$P_1,P_1,P_2,P_3,P_3,P_3,P_4,P_5,P_5,P_6,P_7,P_7$`

>

We will see that `$P_3$` makes the grammar type 0, RE

---

![](http://fondinfo.github.io/images/comp/two-face.png)
# üß™ Parsing and Ambiguity

- **Parsing**: finding the productions that generate a certain string
    - First task of a *compiler*
    - The string is the source code
    - Productions identify the program's syntactic *structure*
- Some grammars are **ambiguous**
    - Different sequences of productions generate the same string
    - ‚ùó The program's structure is not clear

---

# üß™ Derivation Trees (Syntactic)

- Example of an **ambiguous** grammar for **infix** notation: <br> two valid interpretations for `2 + 3 * 3`
    - `$V_t := \{0, 1, 2... 9, +, *, (, )\}, V_n := \{E, N, D\}$`
    - `$E \to E + E | E * E | ( E ) | N$`
    - `$N \to D N | D \\ D \to 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9$`

![](http://fondinfo.github.io/images/comp/ambiguity.svg)

---

# üß™ Infix and Prefix Expressions

- **Infix** notation, with operator *precedence*: `$2 + 3 * 3$`
- *Unambiguous* grammar for infix notation
    - `$E \to T + E | T \\ T \to F * T | F \\ F \to ( E ) | N$`
    - `$N \to D N | D \\ D \to 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9$`
- **Prefix** notation, or *Polish* notation
    - E.g.: `$* + 1\;\;2 - 3\;\;2$` ‚áí Infix: `$(1 + 2) * (3 - 2)$`
- *Grammar* for prefix notation
    - `$E \to N | + E\;\;E | - E\;\;E | * E\;\;E | / E\;\;E$`

>

<https://fondinfo.github.io/play/?c12_polish.py>

---

![](http://fondinfo.github.io/images/comp/hierarchy.svg)
# ‚≠ê Chomsky Hierarchy

- **Type 0**: **RE** grammars, *recursively enumerable*
    - `$\alpha A\beta \to \gamma $` (*unrestricted*)
- **Type 1**: **CS** grammars, *context-sensitive*
    - `$\alpha A\beta \to \alpha \gamma \beta$`
- **Type 2**: **CF** grammars, *context-free*
    - `$A \to \gamma$`
- **Type 3**: **REG** grammars, *regular*
    - `$A \to aB$`, or `$A \to b$`, or `$A \to \varepsilon$` (right REG)
    - Coincides with the class of languages defined by *regex*

>

`$A, B \in V_n; a, b \in V_t; \alpha , \beta , \gamma \in V^\star$`

---

# ‚≠ê Context-Free Languages

- Checking *palindromes*, *parenthesis balancing* and various *symmetries*
    - E.g.: `$\{a^nb^n : n \geq 1\}$` gen. by `$S \to aSb | ab$` (CF)
    - But not: `$\{a^n b^n c^n : n \geq 1\}$` (CS) *‚ú∂*
- Common **programming languages**: CF grammars
    - Balanced parentheses: `$S \to SS | (S) | Œµ$`

>

‚ú∂ In the example `$G_0$` already seen, replace `$P_3$` with: <br>
`$P_{3a} := CB \to HB \\ P_{3b} := HB \to HC \\ P_{3c} := HC \to BC$`

---

# ü•∑ Extended Backus-Naur Form (EBNF)

- Terminals in quotes
- `{...}`: repeatable part (0+), `[...]`: optional part,
- `(...)`: grouping, `|`: choice

``` text
sentence := subject verb complement
subject := article noun
complement := article noun
article := "the"
noun := "cat" | "mouse" | "stone"
verb := "eats" | "drinks"
```

- In the example, these are terminals
    - `the`, `cat`, `mouse`, `stone`, `eats`, `drinks`
- *‚Äú`the cat eats the mouse`‚Äù* is a sentence of the language

---

# ü•∑ EBNF for Expressions

- *Infix notation*, with precedence
    - E.g.: `2 + 3 * 3`

``` text
expr := term {( "+" | "-" ) term}
term := factor {( "*" | "/" ) factor}
factor := number | "(" expr ")" | "-" term
```

- *Prefix, or Polish, notation*
    - E.g.: `* + 1 2 - 3 2` ‚áí Infix: `(1 + 2) * (3 - 2)`

``` text
expr := number | "+" expr expr | "-" expr expr |
                 "*" expr expr | "/" expr expr
number := digit {digit}
digit := "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
```

>

<https://fondinfo.github.io/play/?c12_polish.py>

---

# ü•∑ LL(1) Languages

- Subclass of CF languages
- Each production related to the same non-terminal (on the left)... <br> generates a different terminal as the first symbol
    - No common prefixes, no left recursion
- **Recursive descent parser**: very simple and efficient syntactic analysis
    - Just "peek" at the next input symbol to know with certainty which production to apply

---

![](http://fondinfo.github.io/images/comp/pumping-lemma-3.svg)
# ü•∑ Pumping Lemma REG

- Formally, `$\forall L$` regular...
    - `$\exists k : \forall z \in L, |z| \geq k \\ \exists u,v,w : z=u v w, |uv| \leq k, |v| \geq 1 \\ u v^i w \in L, \forall i \geq 0$`
- In any sufficiently long string,
    - there is a part that can be repeated,
    - generating another string in `$L$`
- For sufficiently long input, parse tree with repetitions of the same non-terminal
- Or: a Finite State Automaton (‚Ä¶), for sufficiently long input, returns to an already visited state

>

Example with `$G_1$`: `$S \to b | aA; A \to aS$`

---

![](http://fondinfo.github.io/images/comp/pumping-lemma-2.svg)
# ü•∑ Pumping Lemma CF

- Formally, `$\forall L$` context-free...
    - `$\exists k : \forall z \in L, |z| \geq k \\ \exists u,v,w,x,y : \\ z=uvwxy, |vwx| \leq k,|vx| \geq 1 \\ u v^i w x^i y \in L, \forall i \geq 0$`
- In any sufficiently long string,
    - there are two parts that can be
    - repeated together, staying in `$L$`
- For sufficiently long input, parse tree with repetitions of the same non-terminal

---

# ü•∑ Corollaries of the Two Lemmas

- ‚áí `$L := \{a^n b^n : n \geq 0\}$` is not REG
    * Take `$a^m b^m, m>k \to |uv|<m$`, all are `$a$`‚Ä¶
- ‚áí `$L := \{a^n b^n c^n : n \geq 0\}$` is not CF
    * Take `$a^m b^m c^m, m>k \to |vwx|<m$`
    * If `$v$` and `$x$` have different symbols, `$u v^2 w x^2 y$` with mixed symbols
    * If `$v$` and `$x$` have only one symbol, `$u v^2 w x^2 y$` with a different number of `$a, b, c$`
    * In both cases, the new string `$z' \notin L$`

---

# Compilers

---

# üí°Ô∏è Programming Language

- *Formal* and *unambiguous* notation for defining algorithms
    - *Algorithm*: sequence of instructions to solve a given problem
- Each language is characterized by:
    - **Syntax**
    - **Semantics**

---

![large](http://fondinfo.github.io/images/dev/syntax-diagrams.png)
# ‚≠ê Syntax

- Set of formal rules for writing well-formed *phrases* (programs) in a certain language
- Often two-level analysis:
- **Lexical**, using *regular expressions*
    - Recognizes "tokens": reserved words, operators, variables, constants, etc.
- **Structure**, using *context-free grammars*
    - Backus-Naur Form
    - Extended BNF
    - Syntax diagrams

---

# ‚≠ê Semantics

- Assigns a **meaning** to (syntactically correct) phrases constructed in the language
- A phrase can be syntactically correct and yet have no meaning
    - Subject ‚Äì predicate ‚Äì object
    - *"The apple eats the child"*
    - *"The child eats the apple"*
- Or have a different meaning than intended...
    - `int pi = 3.14;`

---

# ‚≠ê Use of Semantics

- **Type correctness**
    - What data types can be processed?
    - What operators are applicable to each data?
    - What rules for defining new types and operators?
- **Operational semantics**
    - What is the effect of each elementary action?
    - What is the effect of aggregating actions?
    - That is, what is the effect of executing a certain program?

---

![large](http://fondinfo.github.io/images/dev/compiler.svg)
# ‚≠ê Compiler Architecture

- Translator, often modular
- **Front-end**, high-level language analysis
    - *Lexical*
    - *Grammatical*
    - *Contextual*
- ‚Üí **Intermediate representation**
    - *AST (Annotated Syntax Tree)*
- **Object code generation**
    - Machine language

---

![large](http://fondinfo.github.io/images/dev/ast-euclid.svg)
# üß™ E.g. Syntax Tree

- *Syntactic* analysis: grammatical derivation rules of the source
- *Contextual* analysis: annotations on variable scope and type

``` py
while b != 0:
    if a > b:
        a = a ‚àí b
    else:
        b = b ‚àí a
return a
```

>

Euclidean algorithm for GCD

---

# ü•∑ Program Execution

- Object code not yet executable
- High-level language ‚Üí necessary steps:
    - ‚ûä **Compiler**: translation into machine language
    - ‚ûã **Linker**: linking with support libraries
    - ‚ûå **Loader**: loading into memory
- **Compiled** programs: all 3 steps applied...
    - To all code; before execution
- **Interpreted** programs: all 3 steps applied...
    - Sequentially, on each instruction; at runtime

![](http://fondinfo.github.io/images/dev/build.svg)

---

# ü•∑ Linking

- The **linker** links different object modules
    - Unresolved symbols ‚Üí external references
    - Linking can be static or dynamic
- **Static linking**
    - Library included in the object file, standalone executable
    - Larger size, but possible to include only used functionalities
- **Dynamic linking**
    - Libraries shared by different applications
    - Unique installation and updates
    - Loaded into memory only once

---

![](http://fondinfo.github.io/images/dev/relocation.png)
# ü•∑ Loading

- The **loader** loads a program into memory
    - Resolves logical addresses (variables, jumps, etc.)
    - Loads any support programs (DLLs, etc.)
- **Static relocation**: logical addresses transformed into absolute addresses
- **Dynamic relocation**: logical addresses maintained, relative to the program's position in memory
    - CPU *base registers* (CS, DS, and SS registers on x86): <br> base location of code, data, and stack
    - *Memory Management Unit* in OS

---

# ü•∑ Managed Code

- Compilation into **intermediate code**
    - Bytecode (Java), Common Intermediate Lang. (.NET), ‚Ä¶
    - Python: compiled for a virtual machine (.pyc file), but transparently
- Execution on a **virtual machine**
    - Java Virtual Machine, Common Language Runtime, ‚Ä¶
    - Emulation of a certain processor
    - ‚áí Platform independence
    - "Just In Time" compilation to native code
    - Memory management with *garbage collection*

---

![](http://fondinfo.github.io/images/dev/garbage-truck.svg)
# ü•∑ Garbage Collection Systems

- Automatic memory reclamation
    - For objects/data that are no longer needed
- Also possible for native code
    - *Go* language
    - Extensions and *"smart pointers"* in C++
- Different algorithms
    - *Reference counting*: basic idea, but cycles‚Ä¶
    - *Mark & sweep*: starts from local/global references, marks reachable objects
    - *Generational garbage collection*: frequently checks recent objects

---

# ü•∑ Use of Garbage Collection

- Advantages
    - Systematically frees memory (*memory leak*)
    - Does not remove still useful data (*dangling pointer*)
    - Data relocated to *compact* memory
- Disadvantages
    - Higher *processor* utilization (~1.3x)
    - Higher *memory* utilization (~2x)
    - GC autonomously decides *when* to operate (problem for *real time*)

>

<https://golang.org/src/runtime/mgc.go>
<br>
<https://golang.org/s/go15gcpacing>

---

# Languages and Paradigms

---

![large](http://fondinfo.github.io/images/dev/assembly.png)
# üí°Ô∏è Low-Level Languages

- More machine-oriented than problem-oriented
- **Machine languages**: only operations directly executable by the processor
    - Very elementary operations, different for each processor, in binary format
- **Assembly languages**: first evolution, binary codes ‚Üí mnemonics

---

# üí°Ô∏è High-Level Languages

- Introduced to facilitate program writing
- Intuitive definition of the solution
- With a certain **abstraction** from the computer on which they will be executed
- Must be translated into machine language

>

[The Computer Language Benchmarks Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/python3-gcc.html)
<br>
[Which Programming Languages Use the Least Electricity?](https://thenewstack.io/which-programming-languages-use-the-least-electricity/)

---

# üí°Ô∏è History of Languages

![large](http://fondinfo.github.io/images/dev/languages-timeline.svg)

>

[O‚ÄôReilly Language Poster](https://www.cs.toronto.edu/~gpenn/csc324/PLhistory.pdf)
<br>
[Updated Poster](http://www.levenez.com/lang/history.html)
<br>
[History of Computer Programming Languages, by A. Ferguson](https://cs.brown.edu/~adf/programming_languages.html)
<br>
[The Development of the C Language](https://www.bell-labs.com/usr/dmr/www/chist.html)

---

![large](http://fondinfo.github.io/images/dev/lang-spectrum.png)
# üí°Ô∏è The Top 10

![](http://fondinfo.github.io/images/dev/lang-rank.png)

>

[Spectrum](https://spectrum.ieee.org/top-programming-languages/) - [PYPL](https://pypl.github.io/PYPL.html) - [Redmonk](https://redmonk.com/sogrady/2021/08/05/language-rankings-6-21/) - [Tiobe](https://www.tiobe.com/tiobe-index/)

---

# üí°Ô∏è Development Paradigms

- Provide the philosophy and methodology for writing programs
- Define the (abstract) concept of computation
- Each language allows (or pushes towards) the adoption of a particular paradigm
    - Imperative / procedural
    - Object-oriented
    - Scripting (dynamic typing, DRY principle - Don't Repeat Yourself)
    - Functional (functions as "first-class citizens")
    - Logical (knowledge base + inference rules)

---

# üí°Ô∏è Languages and Paradigms

- **Imperative / procedural**
    - Cobol, Fortran, Algol, C, Pascal
- **Object-oriented**
    - Simula, Smalltalk, Eiffel, Delphi
    - C++, Java, C#, Go, Swift, Rust, ...
- **Scripting**
    - Basic, Perl, PHP, Javascript, Python, VB.NET, Shell, Lua
- **Functional**
    - Lisp, Scheme, ML, Haskell, Erlang
- **Logical**
    - Prolog...
